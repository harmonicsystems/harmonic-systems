<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Live chord detection and MIDI visualizer - connect your keyboard, play chords, and learn music theory through exploration. Built with Tonal.js.">
    <title>Live Chord Analyzer - Harmonic Systems Studio</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600&family=Inter:wght@400;500;600&family=Fraunces:wght@600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tonaljs/tonal/browser/tonal.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/abcjs/dist/abcjs-basic-min.js"></script>
    <style>
        /* Dark mode variables */
        :root {
            --hud-bg: #fafafa;
            --hud-bg-alt: #ffffff;
            --hud-border: #ddd;
            --hud-text: #2c3e50;
            --hud-text-secondary: #7f8c8d;
            --hud-accent: #5d6d7e;
        }

        [data-theme="dark"] {
            --hud-bg: #1a1a2e;
            --hud-bg-alt: #16213e;
            --hud-border: #2a2a4a;
            --hud-text: #eee;
            --hud-text-secondary: #aaa;
            --hud-accent: #7f8fa6;
        }

        [data-theme="dark"] body {
            background: #0f0f1a;
            color: var(--hud-text);
        }

        [data-theme="dark"] .site-nav {
            background: #16213e;
            border-bottom-color: var(--hud-border);
        }

        [data-theme="dark"] .container {
            color: var(--hud-text);
        }

        [data-theme="dark"] h1, [data-theme="dark"] h2, [data-theme="dark"] h3 {
            color: var(--hud-text);
        }

        [data-theme="dark"] .subtitle {
            color: var(--hud-text-secondary);
        }

        [data-theme="dark"] a {
            color: #64b5f6;
        }

        /* HUD Controls Bar */
        .hud-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            padding: 8px 12px;
            background: var(--hud-bg);
            border: 1px solid var(--hud-border);
            border-radius: 6px;
            margin-bottom: 12px;
        }

        .hud-controls label {
            font-size: 0.85em;
            color: var(--hud-text-secondary);
            font-weight: 500;
        }

        .hud-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: var(--hud-bg-alt);
            border: 1px solid var(--hud-border);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            color: var(--hud-text);
            transition: all 0.15s ease;
            user-select: none;
        }

        .hud-toggle:hover {
            border-color: var(--hud-accent);
        }

        .hud-toggle.active {
            background: var(--hud-accent);
            color: white;
            border-color: var(--hud-accent);
        }

        .hud-toggle input {
            display: none;
        }

        .hud-divider {
            width: 1px;
            height: 24px;
            background: var(--hud-border);
            margin: 0 8px;
        }

        /* Collapsible sections */
        .hud-section {
            transition: all 0.2s ease;
            overflow: hidden;
        }

        .hud-section.collapsed {
            display: none;
        }

        /* Dark mode for components */
        [data-theme="dark"] .visualizer {
            background: var(--hud-bg);
            border-color: var(--hud-border);
        }

        [data-theme="dark"] .piano-section {
            background: var(--hud-bg);
            border-color: var(--hud-border);
        }

        [data-theme="dark"] .chord-panel {
            background: var(--hud-bg-alt);
            border-color: var(--hud-border);
        }

        [data-theme="dark"] .chord-name {
            color: var(--hud-text);
        }

        [data-theme="dark"] .chord-name.detecting {
            color: var(--hud-text-secondary);
        }

        [data-theme="dark"] .info-card {
            background: var(--hud-bg-alt);
            border-color: var(--hud-border);
        }

        [data-theme="dark"] .info-card h4 {
            color: var(--hud-text);
        }

        [data-theme="dark"] .info-card p {
            color: var(--hud-text-secondary);
        }

        [data-theme="dark"] .status.waiting {
            background: #3d3d00;
            color: #ffd700;
        }

        [data-theme="dark"] .status.connected {
            background: #1a3d1a;
            color: #90EE90;
        }

        [data-theme="dark"] .status.error {
            background: #3d1a1a;
            color: #ff6b6b;
        }

        [data-theme="dark"] .wave-canvas {
            background: var(--hud-bg-alt);
            border-color: var(--hud-border);
        }

        [data-theme="dark"] .note-display {
            color: var(--hud-text);
        }

        [data-theme="dark"] .frequency-display,
        [data-theme="dark"] .midi-number {
            color: var(--hud-text-secondary);
        }

        [data-theme="dark"] .keyboard-range {
            color: var(--hud-text-secondary);
        }

        [data-theme="dark"] .connect-button {
            background: #4a5568;
        }

        [data-theme="dark"] .connect-button:hover {
            background: #5a6578;
        }

        [data-theme="dark"] select {
            background: var(--hud-bg-alt);
            color: var(--hud-text);
            border-color: var(--hud-border);
        }

        [data-theme="dark"] .piano-key.white-key {
            fill: #e8e8e8;
            stroke: #555;
        }

        [data-theme="dark"] .piano-key.black-key {
            fill: #2a2a2a;
            stroke: #333;
        }

        [data-theme="dark"] .key-label {
            fill: #666;
        }

        [data-theme="dark"] .key-label.black-key-label {
            fill: #999;
        }

        .visualizer {
            background: #fafafa;
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 48px 32px;
            margin: 48px 0;
            text-align: center;
        }

        .wave-canvas {
            width: 100%;
            height: 150px;
            margin: 32px 0;
            background: white;
            border-radius: 4px;
            border: 1px solid var(--border);
            position: relative;
        }

        .wave-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
            margin-top: 8px;
            font-size: 0.85em;
        }

        .wave-info {
            font-family: 'Inter', monospace;
            font-size: 0.8em;
            color: var(--secondary);
            text-align: center;
            margin-top: 8px;
        }

        .freeze-button {
            background: var(--secondary);
            color: white;
            border: none;
            padding: 6px 12px;
            font-size: 0.85em;
            font-weight: 500;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
        }

        .freeze-button:hover {
            background: var(--primary);
        }

        .freeze-button.frozen {
            background: #e74c3c;
        }

        .note-display {
            font-family: 'Fraunces', Georgia, serif;
            font-size: 3em;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 8px;
            /* Fixed height - no more jumping */
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            /* Only transition color, not size */
            transition: color 0.15s ease;
            overflow: hidden;
        }

        /* Scale down when many notes - smaller increments */
        .note-display.many-notes {
            font-size: 2.4em;
            gap: 8px;
        }

        .note-display.lots-of-notes {
            font-size: 1.8em;
            gap: 6px;
        }

        .note-display.active {
            color: #e74c3c;
        }

        .note-item {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.2s ease;
        }

        .note-item .note-name {
            font-size: 1em;
        }

        .note-item .note-hz {
            font-family: 'Inter', sans-serif;
            font-size: 0.3em;
            opacity: 0.7;
            font-weight: 500;
        }

        .note-item.note-0 { color: #e74c3c; }
        .note-item.note-1 { color: #3498db; }
        .note-item.note-2 { color: #2ecc71; }
        .note-item.note-3 { color: #f39c12; }
        .note-item.note-4 { color: #9b59b6; }

        .frequency-display {
            font-family: 'Inter', sans-serif;
            font-size: 0.9em;
            color: var(--secondary);
        }

        .midi-number {
            font-family: 'Inter', monospace;
            font-size: 0.85em;
            color: var(--accent);
        }

        .status {
            padding: 10px 16px;
            border-radius: 4px;
            font-size: 0.9em;
            margin: 12px 0;
            font-weight: 500;
        }

        .status.waiting {
            background: #fff3cd;
            color: #856404;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .connect-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 16px 32px;
            font-size: 1.1em;
            font-weight: 600;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s ease;
        }

        .connect-button:hover {
            background: var(--secondary);
            transform: translateY(-2px);
        }

        .connect-button:disabled {
            background: var(--accent);
            cursor: not-allowed;
            transform: none;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
            margin-top: 32px;
        }

        .info-card {
            background: white;
            padding: 24px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        .info-card h4 {
            font-family: 'Crimson Pro', serif;
            font-size: 1.1em;
            margin-bottom: 8px;
            color: var(--primary);
        }

        .info-card p {
            font-size: 0.95em;
            color: var(--secondary);
            margin: 0;
        }

        /* Piano Keyboard Styles */
        .piano-section {
            margin: 24px 0;
            padding: 20px;
            background: #fafafa;
            border-radius: 8px;
            border: 2px solid var(--border);
        }

        .piano-keyboard {
            width: 100%;
            height: 120px;
            margin: 8px 0;
        }

        .piano-key {
            /* Smooth ADSR-like transitions */
            transition: fill 0.08s ease-out, opacity 0.15s ease-out;
            cursor: pointer;
        }

        .piano-key:hover {
            filter: brightness(0.95);
        }

        .piano-key.white-key {
            fill: #fefefe;
            stroke: var(--primary);
            stroke-width: 1.5;
        }

        .piano-key.black-key {
            fill: var(--primary);
            stroke: var(--primary);
            stroke-width: 1;
        }

        .piano-key.black-key:hover {
            filter: brightness(1.3);
        }

        /* Active states with smooth attack */
        .piano-key.white-key.active {
            transition: fill 0.02s ease-out; /* Fast attack */
        }

        .piano-key.black-key.active {
            transition: fill 0.02s ease-out; /* Fast attack */
        }

        /* Releasing state for smooth decay */
        .piano-key.releasing {
            transition: fill 0.4s ease-out, opacity 0.4s ease-out; /* Slow release */
        }

        /* Spectrum colors for active notes - white keys */
        .piano-key.active.note-C { fill: #E74C3C !important; }
        .piano-key.active.note-D { fill: #E67E22 !important; }
        .piano-key.active.note-E { fill: #F1C40F !important; }
        .piano-key.active.note-F { fill: #27AE60 !important; }
        .piano-key.active.note-G { fill: #3498DB !important; }
        .piano-key.active.note-A { fill: #8E44AD !important; }
        .piano-key.active.note-B { fill: #9B59B6 !important; }

        /* Spectrum colors for active notes - black keys (flats) */
        .piano-key.active.note-Db { fill: #E55A30 !important; }
        .piano-key.active.note-Eb { fill: #F4A420 !important; }
        .piano-key.active.note-Gb { fill: #2D9A8C !important; }
        .piano-key.active.note-Ab { fill: #6B6EC0 !important; }
        .piano-key.active.note-Bb { fill: #954FA1 !important; }

        /* Spectrum colors for active notes - black keys (sharps) */
        .piano-key.active.note-Cs { fill: #E55A30 !important; }
        .piano-key.active.note-Ds { fill: #F4A420 !important; }
        .piano-key.active.note-Fs { fill: #2D9A8C !important; }
        .piano-key.active.note-Gs { fill: #6B6EC0 !important; }
        .piano-key.active.note-As { fill: #954FA1 !important; }

        .key-label {
            font-size: 11px;
            fill: #888;
            font-weight: 500;
            pointer-events: none;
            font-family: 'Inter', sans-serif;
            transition: fill 0.15s ease-out;
        }

        .key-label.black-key-label {
            fill: rgba(255,255,255,0.7);
        }

        .key-label.active {
            fill: #1a1a1a;
            font-weight: 600;
        }

        .key-label.black-key-label.active {
            fill: white;
        }

        /* Chord Detection Panel - COMPACT LAYOUT */
        .chord-panel {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px 16px;
            margin-top: 8px;
            /* Fixed height to prevent layout shifts */
            min-height: 80px;
            display: flex;
            flex-direction: column;
        }

        .chord-name {
            font-family: 'Fraunces', Georgia, serif;
            font-size: 2em;
            font-weight: 700;
            color: var(--primary);
            /* Fixed height container */
            min-height: 40px;
            display: flex;
            align-items: center;
            /* Smooth color transition only, not size */
            transition: color 0.15s ease;
        }

        .chord-name.detecting {
            color: var(--secondary);
            font-size: 1.2em;
        }

        .chord-details {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 4px;
            font-size: 0.9em;
            color: var(--secondary);
            /* Fixed height for details row */
            min-height: 28px;
            align-items: center;
            /* Fade in/out instead of display toggle */
            opacity: 1;
            transition: opacity 0.15s ease;
        }

        .chord-details.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .chord-detail-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .chord-detail-label {
            font-weight: 500;
            color: var(--primary);
        }

        .note-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .note-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 500;
            color: white;
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .keyboard-range {
            font-size: 0.8em;
            color: var(--secondary);
            text-align: center;
            margin-top: 4px;
        }

        /* Stable visualizer container */
        .visualizer {
            min-height: 200px;
        }

        /* Stable piano section */
        .piano-section {
            min-height: 240px;
            padding: 16px;
        }

        /* Stable info cards */
        .info-grid .info-card {
            min-height: 50px;
            padding: 10px !important;
        }

        /* Compact frequency/midi display */
        .freq-midi-row {
            display: flex;
            justify-content: center;
            gap: 24px;
            flex-wrap: wrap;
            margin: 8px 0;
            font-size: 0.95em;
            color: var(--hud-text-secondary);
        }

        .freq-midi-row span {
            white-space: nowrap;
        }

        /* Staff Notation Styles */
        .notation-header {
            color: var(--hud-text-secondary);
        }

        [data-theme="dark"] .notation-header {
            color: var(--hud-text-secondary);
        }

        [data-theme="dark"] .notation-header .notation-label {
            color: var(--hud-text-secondary);
        }

        .notation-section {
            padding: 16px;
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            min-height: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .notation-container {
            width: 100%;
            max-width: 500px;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notation-container svg {
            max-width: 100%;
            height: auto;
        }

        .notation-placeholder {
            color: var(--secondary);
            font-style: italic;
            font-size: 0.95em;
        }

        /* Dark mode for notation */
        [data-theme="dark"] .notation-section {
            background: var(--hud-bg-alt);
            border-color: var(--hud-border);
        }

        [data-theme="dark"] .notation-section .notation-label {
            color: var(--hud-text-secondary);
        }

        [data-theme="dark"] .notation-placeholder {
            color: var(--hud-text-secondary);
        }

        /* Make abcjs SVG work in dark mode - cream/sepia card */
        [data-theme="dark"] .notation-container svg {
            background: #2a2a3e;
            border-radius: 4px;
            padding: 8px;
            filter: invert(0.85) hue-rotate(180deg) saturate(0.8);
        }
    </style>
</head>
<body>
    <nav class="site-nav">
        <div class="container">
            <a href="../" class="nav-home">Harmonic Systems</a>
            <div class="nav-links">
                <a href="../blog/">Blog</a>
                <a href="../lessons/">Lessons</a>
                <a href="../tools/">Tools</a>
                <a href="../playlists/">Playlists</a>
            </div>
        </div>
    </nav>

    <div class="container" style="padding-top: 24px; padding-bottom: 24px;">
        <header style="padding-top: 0; margin-bottom: 16px; padding-bottom: 16px;">
            <h1 style="margin-bottom: 8px;">Live Chord Analyzer</h1>
            <p class="subtitle" style="margin-bottom: 16px;">Play first, understand second. Connect your keyboard and explore music theory through discovery.</p>
        </header>

        <!-- HUD Controls Bar -->
        <div class="hud-controls">
            <label>Display:</label>
            <label class="hud-toggle" id="toggleDarkMode">
                <span>Dark Mode</span>
            </label>
            <div class="hud-divider"></div>
            <label>Show:</label>
            <label class="hud-toggle active" id="toggleWaveform">
                <span>Waveform</span>
            </label>
            <label class="hud-toggle active" id="toggleNoteDisplay">
                <span>Notes</span>
            </label>
            <label class="hud-toggle active" id="toggleMidiInfo">
                <span>MIDI Info</span>
            </label>
            <label class="hud-toggle active" id="toggleNotation">
                <span>Staff</span>
            </label>
        </div>

        <section>
            <div id="status" class="status waiting" style="margin: 12px 0; padding: 12px;">
                Click "Connect MIDI Device" to get started
            </div>

            <button id="connectButton" class="connect-button" style="margin-bottom: 16px;">Connect MIDI Device</button>

            <div class="visualizer" style="padding: 16px; margin: 12px 0;">
                <!-- Note Display Section (collapsible) -->
                <div id="noteDisplaySection" class="hud-section">
                    <div id="noteDisplay" class="note-display" style="margin-bottom: 8px;">
                        Play a note...
                    </div>
                </div>

                <!-- Waveform Section (collapsible) -->
                <div id="waveformSection" class="hud-section">
                    <canvas id="waveCanvas" class="wave-canvas" style="margin: 8px 0; height: 120px;"></canvas>
                    <div class="wave-controls" style="margin-bottom: 4px;">
                        <button id="freezeButton" class="freeze-button">Freeze</button>
                        <label>
                            <input type="checkbox" id="showCyclesCheckbox"> Cycles
                        </label>
                        <label>
                            <input type="checkbox" id="showHarmonicsCheckbox" checked> Harmonics
                        </label>
                        <label style="margin-left: 12px;">
                            Zoom:
                            <input type="range" id="waveZoom" min="0.5" max="3" step="0.25" value="1.5" style="width: 80px; vertical-align: middle;">
                        </label>
                        <span id="waveInfo" class="wave-info" style="margin-left: 12px;"></span>
                    </div>
                    <!-- Combined Hz + MIDI row -->
                    <div class="freq-midi-row">
                        <span id="frequencyDisplay">—</span>
                        <span id="midiDisplay">—</span>
                    </div>
                </div>
            </div>

            <!-- MIDI Info Section (collapsible) -->
            <div id="midiInfoSection" class="hud-section">
                <div class="info-grid" style="margin-top: 8px; gap: 10px;">
                    <div class="info-card">
                        <h4 style="margin-bottom: 4px; font-size: 0.85em;">Last Note</h4>
                        <p id="lastNote" style="margin: 0; font-size: 0.9em;">None</p>
                    </div>
                    <div class="info-card">
                        <h4 style="margin-bottom: 4px; font-size: 0.85em;">Velocity</h4>
                        <p id="velocity" style="margin: 0; font-size: 0.9em;">—</p>
                    </div>
                    <div class="info-card">
                        <h4 style="margin-bottom: 4px; font-size: 0.85em;">Active</h4>
                        <p id="activeNotes" style="margin: 0; font-size: 0.9em;">0</p>
                    </div>
                </div>
            </div>

            <!-- Piano Keyboard & Chord Detection -->
            <div class="piano-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h3 style="margin: 0; font-size: 1.1em;">Live Chord Detection</h3>
                    <select id="notePreference" style="padding: 4px 10px; border: 1px solid var(--hud-border); border-radius: 4px; font-family: 'Inter', sans-serif; font-size: 0.85em; background: var(--hud-bg-alt); color: var(--hud-text);">
                        <option value="sharps">Sharps (C#, D#...)</option>
                        <option value="flats">Flats (Db, Eb...)</option>
                    </select>
                </div>
                <svg class="piano-keyboard" id="piano" viewBox="0 0 840 160" preserveAspectRatio="xMidYMid meet">
                    <!-- Piano keys generated dynamically -->
                </svg>
                <div class="keyboard-range" id="keyboardRange">Showing C3 - B5 (adapts to your playing)</div>

                <div class="chord-panel">
                    <div class="chord-name detecting" id="chordName">Play some notes...</div>
                    <div class="chord-details hidden" id="chordDetails">
                        <div class="chord-detail-item">
                            <span class="chord-detail-label">Notes:</span>
                            <div class="note-badges" id="chordNotes"></div>
                        </div>
                        <div class="chord-detail-item">
                            <span class="chord-detail-label">Intervals:</span>
                            <span id="chordIntervals"></span>
                        </div>
                    </div>
                </div>

                <!-- Live Staff Notation - Header always visible -->
                <div class="notation-header" style="display: flex; justify-content: space-between; align-items: center; margin-top: 16px; margin-bottom: 8px;">
                    <span class="notation-label" style="font-size: 0.85em; color: var(--secondary);">Staff Notation</span>
                    <select id="keySignature" style="padding: 4px 10px; border: 1px solid var(--hud-border); border-radius: 4px; font-family: 'Inter', sans-serif; font-size: 0.8em; background: var(--hud-bg-alt); color: var(--hud-text);">
                        <option value="chromatic">Chromatic (use ♯/♭ pref)</option>
                        <optgroup label="Major Keys">
                            <option value="C">C Major (no ♯/♭)</option>
                            <option value="G">G Major (1♯)</option>
                            <option value="D">D Major (2♯)</option>
                            <option value="A">A Major (3♯)</option>
                            <option value="E">E Major (4♯)</option>
                            <option value="B">B Major (5♯)</option>
                            <option value="F#">F♯ Major (6♯)</option>
                            <option value="F">F Major (1♭)</option>
                            <option value="Bb">B♭ Major (2♭)</option>
                            <option value="Eb">E♭ Major (3♭)</option>
                            <option value="Ab">A♭ Major (4♭)</option>
                            <option value="Db">D♭ Major (5♭)</option>
                            <option value="Gb">G♭ Major (6♭)</option>
                        </optgroup>
                        <optgroup label="Minor Keys">
                            <option value="Am">A Minor (no ♯/♭)</option>
                            <option value="Em">E Minor (1♯)</option>
                            <option value="Bm">B Minor (2♯)</option>
                            <option value="F#m">F♯ Minor (3♯)</option>
                            <option value="C#m">C♯ Minor (4♯)</option>
                            <option value="G#m">G♯ Minor (5♯)</option>
                            <option value="D#m">D♯ Minor (6♯)</option>
                            <option value="Dm">D Minor (1♭)</option>
                            <option value="Gm">G Minor (2♭)</option>
                            <option value="Cm">C Minor (3♭)</option>
                            <option value="Fm">F Minor (4♭)</option>
                            <option value="Bbm">B♭ Minor (5♭)</option>
                            <option value="Ebm">E♭ Minor (6♭)</option>
                        </optgroup>
                    </select>
                </div>
                <div class="notation-section hud-section" id="notationSection">
                    <div class="notation-container" id="notationContainer">
                        <span class="notation-placeholder">Play notes to see notation...</span>
                    </div>
                </div>
            </div>
        </section>

        <hr class="divider" style="margin: 32px 0;">

        <section>
            <h2>About This Tool</h2>
            <p>This tool combines real-time MIDI visualization with <strong>live chord detection</strong>. Play first, understand second - an experiential approach to music theory.</p>

            <p><strong>What you'll see:</strong></p>
            <ul>
                <li>A piano keyboard that lights up as you play (spectrum colors by note)</li>
                <li>Real-time chord detection - the tool identifies what chord you're playing</li>
                <li>Intervals and note structure for detected chords</li>
                <li>Live staff notation - see your chords rendered on a musical staff</li>
                <li>Waveform visualization showing frequency relationships</li>
                <li>Auto-adapting keyboard range (expands to match your playing)</li>
            </ul>

            <p><strong>Visual feedback:</strong> Keys respond with smooth, natural transitions - fast attack when you press, gentle release when you let go. No jarring flashes or game-like effects.</p>

            <p><strong>Staff notation:</strong> Uses <a href="https://www.abcjs.net/">abcjs</a> to render real standard musical notation. The clef automatically adapts - treble for high notes, bass for low notes, and grand staff when you span both ranges.</p>

            <p><strong>Why this matters:</strong> Learning music theory through exploration and discovery, rather than rote memorization, creates deeper understanding. Play what feels right, and let the tool help you understand what you played.</p>

            <p><strong>Privacy:</strong> All processing happens in your browser using <a href="https://github.com/tonaljs/tonal">Tonal.js</a> and <a href="https://www.abcjs.net/">abcjs</a>. Nothing is recorded or sent anywhere.</p>
        </section>

        <hr class="divider">

        <section>
            <h2>Troubleshooting</h2>
            <p><strong>No MIDI devices showing?</strong></p>
            <ul>
                <li>Make sure your MIDI keyboard is plugged in</li>
                <li>Try refreshing the page</li>
                <li>Check that your browser supports Web MIDI API (Chrome, Edge, Opera work well)</li>
                <li>Safari requires macOS 12+ and may need permissions enabled</li>
            </ul>
        </section>

        <footer>
            <p>Part of the Harmonic Systems open-source toolkit</p>
            <p style="margin-top: 16px;"><a href="https://github.com/harmonicsystems/harmonic-systems">View on GitHub</a></p>
        </footer>
    </div>

    <script>
        const noteDisplay = document.getElementById('noteDisplay');
        const frequencyDisplay = document.getElementById('frequencyDisplay');
        const midiDisplay = document.getElementById('midiDisplay');
        const statusDiv = document.getElementById('status');
        const connectButton = document.getElementById('connectButton');
        const lastNoteDiv = document.getElementById('lastNote');
        const velocityDiv = document.getElementById('velocity');
        const activeNotesDiv = document.getElementById('activeNotes');
        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');
        const waveInfo = document.getElementById('waveInfo');
        const freezeButton = document.getElementById('freezeButton');
        const showCyclesCheckbox = document.getElementById('showCyclesCheckbox');
        const showHarmonicsCheckbox = document.getElementById('showHarmonicsCheckbox');

        let midiAccess = null;
        let activeNotes = new Map(); // Map of note -> { frequency, velocity }
        let currentFrequency = 0;
        let animationId = null;
        let useFlats = false;
        let animationFrozen = false;
        let showCycleMarkers = false;
        let showHarmonics = true; // Harmonics on by default!
        let frozenTime = 0;

        // Piano keyboard state
        const pianoSvg = document.getElementById('piano');
        const chordNameDiv = document.getElementById('chordName');
        const chordDetailsDiv = document.getElementById('chordDetails');
        const chordNotesDiv = document.getElementById('chordNotes');
        const chordIntervalsDiv = document.getElementById('chordIntervals');
        const keyboardRangeDiv = document.getElementById('keyboardRange');

        // Auto-ranging keyboard settings
        let displayStartOctave = 3;
        let displayEndOctave = 5;
        const minOctaves = 3; // Always show at least 3 octaves
        let rangeExpandTimeout = null;

        // Note colors for spectrum theme
        const noteColors = {
            'C': '#E74C3C', 'D': '#E67E22', 'E': '#F1C40F', 'F': '#27AE60',
            'G': '#3498DB', 'A': '#8E44AD', 'B': '#9B59B6',
            'Db': '#E55A30', 'Eb': '#F4A420', 'Gb': '#2D9A8C', 'Ab': '#6B6EC0', 'Bb': '#954FA1',
            'C#': '#E55A30', 'D#': '#F4A420', 'F#': '#2D9A8C', 'G#': '#6B6EC0', 'A#': '#954FA1'
        };

        // White and black key patterns
        const whiteKeyNames = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
        const blackKeyPattern = [1, 1, 0, 1, 1, 1, 0]; // 1 = black key after this white key

        // Generate piano keyboard SVG
        function generatePiano() {
            pianoSvg.innerHTML = '';

            const numOctaves = displayEndOctave - displayStartOctave + 1;
            const numWhiteKeys = numOctaves * 7;
            const keyWidth = 840 / numWhiteKeys;
            const keyHeight = 140;
            const blackKeyWidth = keyWidth * 0.6;
            const blackKeyHeight = keyHeight * 0.6;

            // Draw white keys first
            let whiteKeyIndex = 0;
            for (let octave = displayStartOctave; octave <= displayEndOctave; octave++) {
                whiteKeyNames.forEach((noteName, i) => {
                    const x = whiteKeyIndex * keyWidth;
                    const midiNote = (octave + 1) * 12 + [0, 2, 4, 5, 7, 9, 11][i];

                    const key = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    key.setAttribute('x', x);
                    key.setAttribute('y', 0);
                    key.setAttribute('width', keyWidth);
                    key.setAttribute('height', keyHeight);
                    key.setAttribute('class', `piano-key white-key note-${noteName}`);
                    key.setAttribute('data-midi', midiNote);
                    key.setAttribute('data-note', noteName);
                    key.setAttribute('rx', 2);
                    pianoSvg.appendChild(key);

                    // Add label
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', x + keyWidth / 2);
                    label.setAttribute('y', keyHeight - 8);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('class', 'key-label');
                    label.setAttribute('data-midi', midiNote);
                    label.textContent = `${noteName}${octave}`;
                    pianoSvg.appendChild(label);

                    whiteKeyIndex++;
                });
            }

            // Draw black keys on top
            whiteKeyIndex = 0;
            for (let octave = displayStartOctave; octave <= displayEndOctave; octave++) {
                whiteKeyNames.forEach((noteName, i) => {
                    if (blackKeyPattern[i] && !(octave === displayEndOctave && i === 6)) {
                        const x = (whiteKeyIndex + 1) * keyWidth - blackKeyWidth / 2;
                        const blackNoteName = useFlats ?
                            ['Db', 'Eb', null, 'Gb', 'Ab', 'Bb', null][i] :
                            ['C#', 'D#', null, 'F#', 'G#', 'A#', null][i];
                        const midiNote = (octave + 1) * 12 + [1, 3, null, 6, 8, 10, null][i];

                        if (blackNoteName && midiNote) {
                            const key = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            key.setAttribute('x', x);
                            key.setAttribute('y', 0);
                            key.setAttribute('width', blackKeyWidth);
                            key.setAttribute('height', blackKeyHeight);
                            key.setAttribute('class', `piano-key black-key note-${blackNoteName.replace('#', 's')}`);
                            key.setAttribute('data-midi', midiNote);
                            key.setAttribute('data-note', blackNoteName);
                            key.setAttribute('rx', 2);
                            pianoSvg.appendChild(key);

                            // Add label for black key
                            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            label.setAttribute('x', x + blackKeyWidth / 2);
                            label.setAttribute('y', blackKeyHeight - 8);
                            label.setAttribute('text-anchor', 'middle');
                            label.setAttribute('class', 'key-label black-key-label');
                            label.setAttribute('data-midi', midiNote);
                            label.textContent = blackNoteName;
                            pianoSvg.appendChild(label);
                        }
                    }
                    whiteKeyIndex++;
                });
            }

            keyboardRangeDiv.textContent = `Showing C${displayStartOctave} – B${displayEndOctave}`;

            // Add click handlers to all keys
            pianoSvg.querySelectorAll('.piano-key').forEach(key => {
                key.addEventListener('mousedown', handleKeyClick);
                key.addEventListener('mouseup', handleKeyRelease);
                key.addEventListener('mouseleave', handleKeyRelease);
            });
        }

        // Track mouse-clicked notes separately
        const mouseHeldNotes = new Set();

        // Handle mouse click on piano key
        function handleKeyClick(e) {
            const midiNote = parseInt(e.target.getAttribute('data-midi'));
            if (isNaN(midiNote) || mouseHeldNotes.has(midiNote)) return;

            mouseHeldNotes.add(midiNote);
            simulateNoteOn(midiNote, 100); // Default velocity 100
        }

        // Handle mouse release on piano key
        function handleKeyRelease(e) {
            const midiNote = parseInt(e.target.getAttribute('data-midi'));
            if (isNaN(midiNote) || !mouseHeldNotes.has(midiNote)) return;

            mouseHeldNotes.delete(midiNote);
            simulateNoteOff(midiNote);
        }

        // Simulate MIDI note on
        function simulateNoteOn(note, velocity) {
            const frequency = midiToFrequency(note);
            activeNotes.set(note, { frequency, velocity });

            updateNoteDisplay();
            updateKeyboardDisplay();
            detectChord();

            const noteName = midiToNoteName(note);
            lastNoteDiv.textContent = noteName;
            velocityDiv.textContent = velocity;
            activeNotesDiv.textContent = activeNotes.size;
        }

        // Simulate MIDI note off
        function simulateNoteOff(note) {
            activeNotes.delete(note);
            activeNotesDiv.textContent = activeNotes.size;

            updateKeyboardDisplay();
            detectChord();

            if (activeNotes.size === 0) {
                setTimeout(() => {
                    if (activeNotes.size === 0) {
                        updateNoteDisplay();
                        detectChord();
                    }
                }, 1000);
            } else {
                updateNoteDisplay();
            }
        }

        // Auto-expand keyboard range based on played notes
        function checkAndExpandRange(midiNote) {
            const noteOctave = Math.floor(midiNote / 12) - 1;
            let needsRegen = false;

            // Expand range if note is outside current display
            if (noteOctave < displayStartOctave) {
                displayStartOctave = Math.max(0, noteOctave);
                needsRegen = true;
            }
            if (noteOctave > displayEndOctave) {
                displayEndOctave = Math.min(8, noteOctave);
                needsRegen = true;
            }

            // Ensure minimum octave span
            while (displayEndOctave - displayStartOctave + 1 < minOctaves) {
                if (displayEndOctave < 8) displayEndOctave++;
                else if (displayStartOctave > 0) displayStartOctave--;
                else break;
                needsRegen = true;
            }

            if (needsRegen) {
                generatePiano();
                updateKeyboardDisplay();
            }
        }

        // Update keyboard visual state
        function updateKeyboardDisplay() {
            // First, add 'releasing' class to currently active keys that are no longer held
            document.querySelectorAll('.piano-key.active').forEach(key => {
                const midi = parseInt(key.getAttribute('data-midi'));
                if (!activeNotes.has(midi)) {
                    key.classList.add('releasing');
                    key.classList.remove('active');
                    // Remove releasing class after transition
                    setTimeout(() => key.classList.remove('releasing'), 400);
                }
            });

            document.querySelectorAll('.key-label.active').forEach(label => {
                const midi = parseInt(label.getAttribute('data-midi'));
                if (!activeNotes.has(midi)) {
                    label.classList.remove('active');
                }
            });

            // Activate currently held keys
            activeNotes.forEach((noteData, midiNote) => {
                const key = pianoSvg.querySelector(`.piano-key[data-midi="${midiNote}"]`);
                const label = pianoSvg.querySelector(`.key-label[data-midi="${midiNote}"]`);
                if (key) {
                    key.classList.remove('releasing');
                    key.classList.add('active');
                }
                if (label) {
                    label.classList.add('active');
                }
            });
        }

        // Detect chord from active notes using Tonal.js
        // ROCK SOLID music theory: tries multiple enharmonic spellings and inversions
        function detectChord() {
            if (activeNotes.size === 0) {
                chordNameDiv.textContent = 'Play some notes...';
                chordNameDiv.classList.add('detecting');
                chordDetailsDiv.classList.add('hidden');
                updateNotation(); // Clear notation when no notes
                return;
            }

            // Get sorted MIDI notes
            const sortedMidi = Array.from(activeNotes.keys()).sort((a, b) => a - b);

            if (activeNotes.size === 1) {
                const noteName = midiToNoteName(sortedMidi[0]);
                chordNameDiv.textContent = noteName;
                chordNameDiv.classList.remove('detecting');
                chordDetailsDiv.classList.add('hidden');
                updateNotation(); // Show single note on staff too!
                return;
            }

            // For 2 notes, show the interval between them
            if (activeNotes.size === 2) {
                const interval = sortedMidi[1] - sortedMidi[0];
                const intervalName = getIntervalName(interval);
                const noteNames = sortedMidi.map(m => midiToNoteName(m));
                const displayNotes = sortedMidi.map(midi => {
                    const noteIndex = midi % 12;
                    return useFlats ? noteNamesFlats[noteIndex] : noteNamesSharps[noteIndex];
                });

                chordNameDiv.textContent = intervalName;
                chordNameDiv.classList.remove('detecting');
                chordDetailsDiv.classList.remove('hidden');

                // Show note badges
                const badgesHTML = displayNotes.map(note => {
                    const color = noteColors[note] || '#888';
                    return `<span class="note-badge" style="background: ${color}">${note}</span>`;
                }).join('');
                chordNotesDiv.innerHTML = badgesHTML;
                chordIntervalsDiv.textContent = `${interval} semitones`;

                updateNotation();
                return;
            }

            // Get note names based on user preference
            const noteNames = sortedMidi.map(midi => {
                const noteIndex = midi % 12;
                return useFlats ? noteNamesFlats[noteIndex] : noteNamesSharps[noteIndex];
            });

            // ROBUST CHORD DETECTION
            // Try multiple strategies to find the chord
            let allDetected = [];
            const bassNote = noteNames[0]; // Lowest note is likely the root

            // Strategy 1: Try all enharmonic spellings and collect ALL detections
            const spellings = getAllEnharmonicSpellings(noteNames);
            for (const spelling of spellings) {
                const detected = Tonal.Chord.detect(spelling);
                allDetected.push(...detected);
            }

            // Strategy 2: Try with bass note first (root position bias)
            for (const spelling of spellings) {
                // Put bass note first and try detection
                const bassFirst = [spelling[0], ...spelling.slice(1).sort()];
                const detected = Tonal.Chord.detect(bassFirst);
                allDetected.push(...detected);
            }

            // Strategy 3: Try inversions with each spelling
            if (noteNames.length >= 3) {
                for (const spelling of spellings) {
                    for (let i = 1; i < spelling.length; i++) {
                        const rotated = [...spelling.slice(i), ...spelling.slice(0, i)];
                        const detected = Tonal.Chord.detect(rotated);
                        allDetected.push(...detected);
                    }
                }
            }

            // Strategy 4: Remove duplicate pitch classes and try again
            const uniqueNotes = [...new Set(noteNames.map(n => normalizeNote(n, useFlats)))];
            if (uniqueNotes.length !== noteNames.length && uniqueNotes.length >= 2) {
                for (const preferFlats of [true, false]) {
                    const normalized = uniqueNotes.map(n => normalizeNote(n, preferFlats));
                    const detected = Tonal.Chord.detect(normalized);
                    allDetected.push(...detected);
                }
            }

            // Remove duplicates
            allDetected = [...new Set(allDetected)];

            // Display notes in user's preferred notation
            const displayNotes = noteNames.map(n => normalizeNote(n, useFlats));
            const displayBassNote = normalizeNote(bassNote, useFlats);

            if (allDetected.length > 0) {
                // Get the BEST chord match using scoring
                const chordSymbol = getBestChord(allDetected, displayBassNote);
                const chord = Tonal.Chord.get(chordSymbol);

                // Convert chord symbol to user's preferred notation
                let displaySymbol = chordSymbol;
                if (useFlats) {
                    displaySymbol = chordSymbol.replace(/([A-G])#/g, (match, note) => {
                        return sharpToFlat[note + '#'] || match;
                    });
                } else {
                    displaySymbol = chordSymbol.replace(/([A-G])b/g, (match, note) => {
                        return flatToSharp[note + 'b'] || match;
                    });
                }

                // Detect inversion - if bass note differs from chord root
                const chordRoot = chord.tonic ? normalizeNote(chord.tonic, useFlats) : null;
                if (chordRoot && chordRoot !== displayBassNote) {
                    // It's an inversion! Show as "Chord/Bass"
                    displaySymbol = `${displaySymbol}/${displayBassNote}`;
                }

                chordNameDiv.textContent = displaySymbol;
                chordNameDiv.classList.remove('detecting');
                chordDetailsDiv.classList.remove('hidden');

                // Create note badges with colors
                const badgesHTML = displayNotes.map(note => {
                    const color = noteColors[note] || noteColors[normalizeNote(note, true)] || '#888';
                    return `<span class="note-badge" style="background: ${color}">${note}</span>`;
                }).join('');
                chordNotesDiv.innerHTML = badgesHTML;

                // Show intervals
                if (chord.intervals && chord.intervals.length > 0) {
                    chordIntervalsDiv.textContent = chord.intervals.join(' · ');
                } else {
                    chordIntervalsDiv.textContent = '—';
                }
            } else {
                // No chord detected - show notes as combination
                chordNameDiv.textContent = displayNotes.join(' + ');
                chordNameDiv.classList.add('detecting');

                // Still show the notes
                chordDetailsDiv.classList.remove('hidden');
                const badgesHTML = displayNotes.map(note => {
                    const color = noteColors[note] || noteColors[normalizeNote(note, true)] || '#888';
                    return `<span class="note-badge" style="background: ${color}">${note}</span>`;
                }).join('');
                chordNotesDiv.innerHTML = badgesHTML;
                chordIntervalsDiv.textContent = 'exploring...';
            }

            // Update staff notation
            updateNotation();
        }

        // ===== HUD CONTROLS =====

        // HUD Toggle Elements
        const toggleDarkMode = document.getElementById('toggleDarkMode');
        const toggleWaveform = document.getElementById('toggleWaveform');
        const toggleNoteDisplay = document.getElementById('toggleNoteDisplay');
        const toggleMidiInfo = document.getElementById('toggleMidiInfo');
        const toggleNotation = document.getElementById('toggleNotation');

        // HUD Sections
        const waveformSection = document.getElementById('waveformSection');
        const noteDisplaySection = document.getElementById('noteDisplaySection');
        const midiInfoSection = document.getElementById('midiInfoSection');
        const notationSection = document.getElementById('notationSection');

        // Load HUD preferences from localStorage
        const hudPrefs = JSON.parse(localStorage.getItem('hud-preferences') || '{}');

        // Apply saved dark mode preference (default: off)
        if (hudPrefs.darkMode) {
            document.documentElement.setAttribute('data-theme', 'dark');
            toggleDarkMode.classList.add('active');
        } else {
            toggleDarkMode.classList.remove('active');
        }

        // Apply saved section visibility (default: all visible)
        if (hudPrefs.waveform === false) {
            waveformSection.classList.add('collapsed');
            toggleWaveform.classList.remove('active');
        }
        if (hudPrefs.noteDisplay === false) {
            noteDisplaySection.classList.add('collapsed');
            toggleNoteDisplay.classList.remove('active');
        }
        if (hudPrefs.midiInfo === false) {
            midiInfoSection.classList.add('collapsed');
            toggleMidiInfo.classList.remove('active');
        }
        if (hudPrefs.notation === false) {
            notationSection.classList.add('collapsed');
            toggleNotation.classList.remove('active');
        }

        // Save HUD preferences
        function saveHudPrefs() {
            const prefs = {
                darkMode: document.documentElement.getAttribute('data-theme') === 'dark',
                waveform: !waveformSection.classList.contains('collapsed'),
                noteDisplay: !noteDisplaySection.classList.contains('collapsed'),
                midiInfo: !midiInfoSection.classList.contains('collapsed'),
                notation: !notationSection.classList.contains('collapsed')
            };
            localStorage.setItem('hud-preferences', JSON.stringify(prefs));
        }

        // Dark Mode Toggle
        toggleDarkMode.addEventListener('click', () => {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            if (isDark) {
                document.documentElement.removeAttribute('data-theme');
                toggleDarkMode.classList.remove('active');
            } else {
                document.documentElement.setAttribute('data-theme', 'dark');
                toggleDarkMode.classList.add('active');
            }
            saveHudPrefs();
        });

        // Waveform Toggle
        toggleWaveform.addEventListener('click', () => {
            waveformSection.classList.toggle('collapsed');
            toggleWaveform.classList.toggle('active');
            saveHudPrefs();
        });

        // Note Display Toggle
        toggleNoteDisplay.addEventListener('click', () => {
            noteDisplaySection.classList.toggle('collapsed');
            toggleNoteDisplay.classList.toggle('active');
            saveHudPrefs();
        });

        // MIDI Info Toggle
        toggleMidiInfo.addEventListener('click', () => {
            midiInfoSection.classList.toggle('collapsed');
            toggleMidiInfo.classList.toggle('active');
            saveHudPrefs();
        });

        // Notation Toggle
        toggleNotation.addEventListener('click', () => {
            notationSection.classList.toggle('collapsed');
            toggleNotation.classList.toggle('active');
            saveHudPrefs();
        });

        // ===== END HUD CONTROLS =====

        // Load notation preference from localStorage BEFORE generating piano
        const savedNotation = localStorage.getItem('notation-preference');
        if (savedNotation) {
            useFlats = savedNotation === 'flats';
        }

        const notePreferenceSelect = document.getElementById('notePreference');
        notePreferenceSelect.value = useFlats ? 'flats' : 'sharps';

        // Initialize piano keyboard with correct notation
        generatePiano();

        notePreferenceSelect.addEventListener('change', (e) => {
            useFlats = e.target.value === 'flats';
            localStorage.setItem('notation-preference', e.target.value);
            generatePiano(); // Regenerate keyboard with new notation
            updateKeyboardDisplay();
            detectChord();
        });

        freezeButton.addEventListener('click', () => {
            animationFrozen = !animationFrozen;
            if (animationFrozen) {
                frozenTime = Date.now() * 0.001;
                freezeButton.textContent = 'Resume Animation';
                freezeButton.classList.add('frozen');
            } else {
                freezeButton.textContent = 'Freeze Animation';
                freezeButton.classList.remove('frozen');
            }
        });

        showCyclesCheckbox.addEventListener('change', (e) => {
            showCycleMarkers = e.target.checked;
        });

        showHarmonicsCheckbox.addEventListener('change', (e) => {
            showHarmonics = e.target.checked;
        });

        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Note names - comprehensive enharmonic mappings
        const noteNamesSharps = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const noteNamesFlats = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

        // Enharmonic equivalents for normalization
        const sharpToFlat = {
            'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb',
            'E#': 'F', 'B#': 'C', 'Fb': 'E', 'Cb': 'B'
        };
        const flatToSharp = {
            'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#',
            'Fb': 'E', 'Cb': 'B', 'E#': 'F', 'B#': 'C'
        };

        // Normalize a note to preferred spelling (flats or sharps)
        function normalizeNote(note, preferFlats = true) {
            const baseNote = note.replace(/[0-9]/g, '');
            if (preferFlats && flatToSharp[baseNote]) {
                return baseNote; // Already a flat
            }
            if (preferFlats && sharpToFlat[baseNote]) {
                return sharpToFlat[baseNote]; // Convert sharp to flat
            }
            if (!preferFlats && sharpToFlat[baseNote]) {
                return baseNote; // Already a sharp
            }
            if (!preferFlats && flatToSharp[baseNote]) {
                return flatToSharp[baseNote]; // Convert flat to sharp
            }
            return baseNote; // Natural note
        }

        // Get all enharmonic spellings of a note set for chord detection
        function getAllEnharmonicSpellings(notes) {
            const spellings = [];

            // All flats
            spellings.push(notes.map(n => normalizeNote(n, true)));

            // All sharps
            spellings.push(notes.map(n => normalizeNote(n, false)));

            // Original
            spellings.push([...notes]);

            return spellings;
        }

        // Score a chord name - simpler/more common chords score higher
        function scoreChordName(chordName) {
            if (!chordName) return 0;

            let score = 100;

            // HEAVILY prefer basic triads - these are the most common chords
            if (/^[A-G][b#]?$/.test(chordName)) score += 200; // Major triad (just "C", "Eb")
            else if (/^[A-G][b#]?m$/.test(chordName)) score += 190; // Minor triad
            else if (/^[A-G][b#]?dim$/.test(chordName)) score += 150; // Diminished
            else if (/^[A-G][b#]?aug$/.test(chordName)) score += 140; // Augmented
            else if (/^[A-G][b#]?maj7$/.test(chordName)) score += 130;
            else if (/^[A-G][b#]?7$/.test(chordName)) score += 130;
            else if (/^[A-G][b#]?m7$/.test(chordName)) score += 130;
            else if (/^[A-G][b#]?sus[24]$/.test(chordName)) score += 120;

            // HEAVILY penalize altered/exotic chords - these are rarely what users mean
            if (chordName.includes('#5')) score -= 150; // Augmented 5th variants
            if (chordName.includes('b5')) score -= 100;
            if (chordName.includes('#9')) score -= 80;
            if (chordName.includes('b9')) score -= 80;
            if (chordName.includes('#11')) score -= 80;
            if (chordName.includes('b13')) score -= 80;
            if (chordName.includes('add')) score -= 40;

            // Penalize long/complex chord names
            if (chordName.length > 4) score -= (chordName.length - 4) * 10;

            return score;
        }

        // Find the best chord from a list of detections
        function getBestChord(detections, bassNote) {
            if (!detections || detections.length === 0) return null;

            // Score each detection - NO bass bonus, just prefer simple chords
            const scored = detections.map(name => ({
                name,
                score: scoreChordName(name)
            }));

            // Sort by score (descending)
            scored.sort((a, b) => b.score - a.score);

            return scored[0]?.name || detections[0];
        }

        function midiToNoteName(midiNumber) {
            const octave = Math.floor(midiNumber / 12) - 1;
            const noteNames = useFlats ? noteNamesFlats : noteNamesSharps;
            const noteName = noteNames[midiNumber % 12];
            return `${noteName}${octave}`;
        }

        // Get musical interval name from semitone distance
        function getIntervalName(semitones) {
            const intervals = {
                0: 'Unison',
                1: 'Minor 2nd',
                2: 'Major 2nd',
                3: 'Minor 3rd',
                4: 'Major 3rd',
                5: 'Perfect 4th',
                6: 'Tritone',
                7: 'Perfect 5th',
                8: 'Minor 6th',
                9: 'Major 6th',
                10: 'Minor 7th',
                11: 'Major 7th',
                12: 'Octave',
                13: 'Minor 9th',
                14: 'Major 9th',
                15: 'Minor 10th',
                16: 'Major 10th',
                17: 'Perfect 11th',
                18: 'Augmented 11th',
                19: 'Perfect 12th',
                20: 'Minor 13th',
                21: 'Major 13th',
                22: 'Minor 14th',
                23: 'Major 14th',
                24: '2 Octaves'
            };
            return intervals[semitones] || `${semitones} semitones`;
        }

        // Get spectrum color for a MIDI note (matches piano key colors)
        function getNoteColor(midiNumber) {
            const noteIndex = midiNumber % 12;
            const noteNames = useFlats ? noteNamesFlats : noteNamesSharps;
            const noteName = noteNames[noteIndex];
            // Strip octave number if present and get base note
            const baseNote = noteName.replace(/[0-9]/g, '');
            return noteColors[baseNote] || '#888';
        }

        function midiToFrequency(midiNumber) {
            // A4 = 440 Hz = MIDI note 69
            return Math.round(440 * Math.pow(2, (midiNumber - 69) / 12) * 100) / 100;
        }

        function updateStatus(message, type = 'waiting') {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }

        function updateNoteDisplay() {
            // Remove responsive classes first
            noteDisplay.classList.remove('many-notes', 'lots-of-notes');
            frequencyDisplay.classList.remove('many-notes');
            midiDisplay.classList.remove('many-notes');

            if (activeNotes.size === 0) {
                noteDisplay.innerHTML = 'Play a note...';
                frequencyDisplay.textContent = '—';
                midiDisplay.textContent = '—';
                return;
            }

            // Apply responsive classes based on number of notes
            if (activeNotes.size >= 6) {
                noteDisplay.classList.add('lots-of-notes');
                frequencyDisplay.classList.add('many-notes');
                midiDisplay.classList.add('many-notes');
            } else if (activeNotes.size >= 4) {
                noteDisplay.classList.add('many-notes');
                frequencyDisplay.classList.add('many-notes');
                midiDisplay.classList.add('many-notes');
            }

            // Sort notes by MIDI number (low to high)
            const sortedNotes = Array.from(activeNotes.keys()).sort((a, b) => a - b);

            // Create HTML for all notes with spectrum colors matching piano keys
            const notesHTML = sortedNotes.map((note) => {
                const noteName = midiToNoteName(note);
                const frequency = midiToFrequency(note);
                const color = getNoteColor(note);
                return `<span class="note-item" style="color: ${color}">
                    <span class="note-name">${noteName}</span>
                    <span class="note-hz">${frequency} Hz</span>
                </span>`;
            }).join(' ');

            noteDisplay.innerHTML = notesHTML;

            // Show ALL frequencies
            const allFrequencies = sortedNotes.map(note => midiToFrequency(note));
            if (activeNotes.size === 1) {
                frequencyDisplay.textContent = `${allFrequencies[0]} Hz`;
            } else {
                frequencyDisplay.textContent = allFrequencies.map(f => `${f} Hz`).join(' · ');
            }
            midiDisplay.textContent = activeNotes.size === 1 ? `MIDI ${sortedNotes[0]}` : `MIDI ${sortedNotes.join(', ')}`;
        }

        // Draw animated sine wave
        function drawWave() {
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            const centerY = height / 2;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Draw center line first
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Get all active notes with their MIDI numbers for color matching
            const noteEntries = Array.from(activeNotes.entries()); // [[midiNote, {frequency, velocity}], ...]

            if (noteEntries.length === 0) {
                waveInfo.textContent = '';
                // Continue animation even when no note
                requestAnimationFrame(drawWave);
                return;
            }

            // Animate the wave (or freeze it)
            const time = animationFrozen ? frozenTime : Date.now() * 0.001;

            // Get zoom level from slider (fewer cycles = more zoomed in)
            const zoomSlider = document.getElementById('waveZoom');
            const cyclesShown = zoomSlider ? parseFloat(zoomSlider.value) : 1.5;
            const pixelsPerCycle = width / cyclesShown;

            // Update info display
            let infoText = `${cyclesShown} cycles`;
            if (noteEntries.length === 1) {
                const vel = noteEntries[0][1].velocity;
                infoText += ` · vel ${Math.round(vel/127*100)}%`;
            } else {
                infoText += ` · ${noteEntries.length} notes`;
            }
            waveInfo.textContent = infoText;

            // Draw cycle markers if enabled
            if (showCycleMarkers) {
                ctx.strokeStyle = '#95a5a6';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                for (let i = 0; i <= cyclesShown; i++) {
                    const x = (i / cyclesShown) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                // Label the cycles
                ctx.fillStyle = '#95a5a6';
                ctx.font = '10px Inter';
                for (let i = 0; i <= cyclesShown; i++) {
                    const x = (i / cyclesShown) * width;
                    ctx.fillText(`${i}`, x + 2, 12);
                }
            }

            // Draw each active frequency with optional harmonics
            noteEntries.forEach(([midiNote, noteData], index) => {
                const freq = noteData.frequency;
                const velocity = noteData.velocity;

                // Velocity affects amplitude: soft = small waves, hard = big waves
                const velocityScale = 0.3 + (velocity / 127) * 0.7; // Range: 0.3 to 1.0
                const baseAmplitude = height * 0.35 / noteEntries.length;
                const amplitude = baseAmplitude * velocityScale;

                // Velocity affects line width: soft = thin, hard = thick
                const lineWidth = 1 + (velocity / 127) * 2.5; // Range: 1 to 3.5

                // Velocity affects opacity: soft = transparent, hard = solid
                const opacity = 0.4 + (velocity / 127) * 0.6; // Range: 0.4 to 1.0

                // Use spectrum color matching the piano key!
                const baseColor = getNoteColor(midiNote);

                const offsetY = centerY + (index - (noteEntries.length - 1) / 2) * amplitude * 0.5;

                // Draw harmonics FIRST (behind the fundamental) if enabled
                if (showHarmonics) {
                    // Natural harmonic series: 2nd, 3rd, 4th, 5th, 6th harmonics
                    // Amplitude decreases as 1/n, opacity fades out
                    const numHarmonics = 6;

                    for (let h = numHarmonics; h >= 2; h--) {
                        const harmonicFreq = freq * h;
                        const harmonicAmplitude = amplitude / h; // Natural 1/n falloff
                        const harmonicOpacity = opacity * (0.5 / h); // Fade out higher harmonics
                        const harmonicLineWidth = Math.max(0.5, lineWidth / (h * 0.7));

                        ctx.strokeStyle = baseColor;
                        ctx.globalAlpha = harmonicOpacity;
                        ctx.lineWidth = harmonicLineWidth;
                        ctx.beginPath();

                        for (let x = 0; x <= width; x += 2) { // Step by 2 for performance
                            const cycles = (x / width) * cyclesShown;
                            const phase = cycles * Math.PI * 2 * h; // Harmonic multiplier
                            const animatedPhase = phase - (time * harmonicFreq / 100);
                            const y = offsetY + Math.sin(animatedPhase) * harmonicAmplitude;

                            if (x === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.stroke();
                    }
                }

                // Draw fundamental frequency ON TOP
                ctx.strokeStyle = baseColor;
                ctx.globalAlpha = opacity;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();

                for (let x = 0; x <= width; x += 1) {
                    const cycles = (x / width) * cyclesShown;
                    const phase = cycles * Math.PI * 2;
                    const animatedPhase = phase - (time * freq / 100);
                    const y = offsetY + Math.sin(animatedPhase) * amplitude;

                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                ctx.globalAlpha = 1.0; // Reset opacity
            });

            // Continue animation
            requestAnimationFrame(drawWave);
        }

        // Start drawing loop
        drawWave();

        function onMIDIMessage(event) {
            const [command, note, velocity] = event.data;

            // Note on (144-159) or note off (128-143)
            const isNoteOn = (command >= 144 && command <= 159) && velocity > 0;
            const isNoteOff = (command >= 128 && command <= 143) || velocity === 0;

            if (isNoteOn) {
                const noteName = midiToNoteName(note);
                const frequency = midiToFrequency(note);

                // Store note with frequency AND velocity
                activeNotes.set(note, { frequency, velocity });

                // Check if we need to expand keyboard range
                checkAndExpandRange(note);

                // Update displays
                updateNoteDisplay();
                updateKeyboardDisplay();
                detectChord();

                noteDisplay.classList.add('active');
                lastNoteDiv.textContent = noteName;
                velocityDiv.textContent = velocity;
                activeNotesDiv.textContent = activeNotes.size;

                setTimeout(() => {
                    noteDisplay.classList.remove('active');
                }, 200);
            }

            if (isNoteOff) {
                activeNotes.delete(note);
                activeNotesDiv.textContent = activeNotes.size;

                // Update keyboard and chord detection
                updateKeyboardDisplay();
                detectChord();

                if (activeNotes.size === 0) {
                    setTimeout(() => {
                        if (activeNotes.size === 0) {
                            updateNoteDisplay();
                            detectChord();
                        }
                    }, 1000);
                } else {
                    // Update to show remaining notes
                    updateNoteDisplay();
                }
            }
        }

        function onMIDISuccess(access) {
            midiAccess = access;
            const inputs = midiAccess.inputs;

            if (inputs.size === 0) {
                updateStatus('No MIDI devices found. Please connect a MIDI keyboard and try again.', 'error');
                return;
            }

            updateStatus(`Connected! Found ${inputs.size} MIDI device(s). Play some notes!`, 'connected');
            connectButton.disabled = true;
            connectButton.textContent = 'Connected';

            // Listen to all MIDI inputs
            inputs.forEach((input) => {
                input.onmidimessage = onMIDIMessage;
            });
        }

        function onMIDIFailure() {
            updateStatus('Failed to access MIDI devices. Make sure you granted permission and your browser supports Web MIDI.', 'error');
        }

        connectButton.addEventListener('click', () => {
            if (navigator.requestMIDIAccess) {
                updateStatus('Requesting MIDI access...', 'waiting');
                navigator.requestMIDIAccess()
                    .then(onMIDISuccess)
                    .catch(onMIDIFailure);
            } else {
                updateStatus('Web MIDI API is not supported in this browser. Try Chrome, Edge, or Opera.', 'error');
            }
        });

        // Check for support on load
        if (!navigator.requestMIDIAccess) {
            updateStatus('Web MIDI API is not supported in this browser. Try Chrome, Edge, or Opera.', 'error');
            connectButton.disabled = true;
        }

        // ===== LIVE STAFF NOTATION WITH ABCJS =====

        const notationContainer = document.getElementById('notationContainer');
        const keySignatureSelect = document.getElementById('keySignature');
        let notationDebounceTimer = null;
        const NOTATION_DEBOUNCE_MS = 150; // Slight delay to avoid flicker
        let selectedKeySignature = 'chromatic'; // Default to chromatic (use sharps/flats pref)

        // Key signature definitions: which notes are sharp or flat in each key
        // Values are MIDI note indices (0-11) that are altered in that key
        const keySignatures = {
            // Major keys with sharps (F C G D A E B)
            'C':  { sharps: [], flats: [] },
            'G':  { sharps: [6], flats: [] },           // F#
            'D':  { sharps: [6, 1], flats: [] },        // F#, C#
            'A':  { sharps: [6, 1, 8], flats: [] },     // F#, C#, G#
            'E':  { sharps: [6, 1, 8, 3], flats: [] },  // F#, C#, G#, D#
            'B':  { sharps: [6, 1, 8, 3, 10], flats: [] }, // F#, C#, G#, D#, A#
            'F#': { sharps: [6, 1, 8, 3, 10, 5], flats: [] }, // F#, C#, G#, D#, A#, E#
            // Major keys with flats (B E A D G C F)
            'F':  { sharps: [], flats: [10] },          // Bb
            'Bb': { sharps: [], flats: [10, 3] },       // Bb, Eb
            'Eb': { sharps: [], flats: [10, 3, 8] },    // Bb, Eb, Ab
            'Ab': { sharps: [], flats: [10, 3, 8, 1] }, // Bb, Eb, Ab, Db
            'Db': { sharps: [], flats: [10, 3, 8, 1, 6] }, // Bb, Eb, Ab, Db, Gb
            'Gb': { sharps: [], flats: [10, 3, 8, 1, 6, 11] }, // Bb, Eb, Ab, Db, Gb, Cb
            // Minor keys (relative minors use same accidentals)
            'Am':  { sharps: [], flats: [] },
            'Em':  { sharps: [6], flats: [] },
            'Bm':  { sharps: [6, 1], flats: [] },
            'F#m': { sharps: [6, 1, 8], flats: [] },
            'C#m': { sharps: [6, 1, 8, 3], flats: [] },
            'G#m': { sharps: [6, 1, 8, 3, 10], flats: [] },
            'D#m': { sharps: [6, 1, 8, 3, 10, 5], flats: [] },
            'Dm':  { sharps: [], flats: [10] },
            'Gm':  { sharps: [], flats: [10, 3] },
            'Cm':  { sharps: [], flats: [10, 3, 8] },
            'Fm':  { sharps: [], flats: [10, 3, 8, 1] },
            'Bbm': { sharps: [], flats: [10, 3, 8, 1, 6] },
            'Ebm': { sharps: [], flats: [10, 3, 8, 1, 6, 11] }
        };

        // Handle key signature changes
        keySignatureSelect.addEventListener('change', (e) => {
            selectedKeySignature = e.target.value;
            localStorage.setItem('key-signature-preference', selectedKeySignature);
            updateNotation(); // Re-render with new key
        });

        // Load saved key signature preference
        const savedKeySig = localStorage.getItem('key-signature-preference');
        if (savedKeySig) {
            selectedKeySignature = savedKeySig;
            keySignatureSelect.value = savedKeySig;
        }

        // Convert MIDI note number to ABC notation
        // ABC uses: C,D,E,F,G,A,B = octave below middle C (C3)
        //           C D E F G A B = middle C octave (C4)
        //           c d e f g a b = octave above middle C (C5)
        //           c' d' e' = C6, etc.
        //           C, D, E, = C2, etc.
        function midiToABC(midiNote, keySignature = 'chromatic') {
            const noteIndex = midiNote % 12;
            const octave = Math.floor(midiNote / 12) - 1; // MIDI octave

            let noteName;

            if (keySignature === 'chromatic') {
                // Use the global sharps/flats preference
                const abcNotesSharps = ['C', '^C', 'D', '^D', 'E', 'F', '^F', 'G', '^G', 'A', '^A', 'B'];
                const abcNotesFlats = ['C', '_D', 'D', '_E', 'E', 'F', '_G', 'G', '_A', 'A', '_B', 'B'];
                const abcNotes = useFlats ? abcNotesFlats : abcNotesSharps;
                noteName = abcNotes[noteIndex];
            } else {
                // Use key signature context
                const keySig = keySignatures[keySignature];
                const isFlatKey = keySig.flats.length > 0;
                const isSharpKey = keySig.sharps.length > 0;

                // MIDI indices: C=0, C#=1, D=2, D#=3, E=4, F=5, F#=6, G=7, G#=8, A=9, A#=10, B=11
                const isBlackKey = [false, true, false, true, false, false, true, false, true, false, true, false];
                const whiteKeyNames = ['C', '', 'D', '', 'E', 'F', '', 'G', '', 'A', '', 'B'];

                // For flat keys: the KEY SIGNATURE alters these WHITE keys
                // Bb key sig means B->Bb, so MIDI 11 (B) becomes Bb, and MIDI 10 (A#/Bb) is "in key"
                // We need to map: which white key gets flatted?
                // Bb = B is flatted (white key index 11 -> plays as 10)
                // Eb = E is flatted (white key index 4 -> plays as 3)
                // Ab = A is flatted (white key index 9 -> plays as 8)
                // Db = D is flatted (white key index 2 -> plays as 1)
                // Gb = G is flatted (white key index 7 -> plays as 6)
                // Cb = C is flatted (white key index 0 -> plays as 11)

                // The flats array contains the BLACK KEY midi indices that are "in the key"
                // We need to check: if playing a WHITE key that would normally be flatted, show natural
                const flatToNatural = { 10: 11, 3: 4, 8: 9, 1: 2, 6: 7, 11: 0 }; // black key -> its natural white key
                const naturalToFlat = { 11: 10, 4: 3, 9: 8, 2: 1, 7: 6, 0: 11 }; // white key -> its flatted version

                // For sharp keys: F#, C#, G#, D#, A#, E# - the sharp is on the BLACK key
                // If playing the WHITE key (F, C, G, D, A, E) when key sig has the sharp, need natural
                const sharpToNatural = { 6: 5, 1: 0, 8: 7, 3: 2, 10: 9, 5: 4 }; // F#->F, C#->C, etc.
                const naturalToSharp = { 5: 6, 0: 1, 7: 8, 2: 3, 9: 10, 4: 5 }; // F->F#, C->C#, etc.

                if (!isBlackKey[noteIndex]) {
                    // Playing a WHITE key
                    const whiteKeyName = whiteKeyNames[noteIndex];

                    // Check if this white key's sharp version is in the key signature
                    const sharpVersion = naturalToSharp[noteIndex];
                    if (sharpVersion !== undefined && keySig.sharps.includes(sharpVersion)) {
                        // The key signature sharps this note, but we're playing the natural!
                        // Need a natural sign
                        noteName = '=' + whiteKeyName;
                    } else {
                        // Check flat keys too
                        const flatVersion = naturalToFlat[noteIndex];
                        if (flatVersion !== undefined && keySig.flats.includes(flatVersion)) {
                            // The key signature flats this note, but we're playing the natural!
                            noteName = '=' + whiteKeyName;
                        } else {
                            // This white key is not affected by the key signature
                            noteName = whiteKeyName;
                        }
                    }
                } else {
                    // Playing a BLACK key
                    if (isFlatKey) {
                        // Use flat spelling
                        const flatNames = { 1: 'D', 3: 'E', 6: 'G', 8: 'A', 10: 'B' };
                        const baseName = flatNames[noteIndex];
                        if (keySig.flats.includes(noteIndex)) {
                            // This flat is in the key sig - no accidental needed
                            noteName = baseName;
                        } else {
                            // Flat not in key sig - need explicit flat
                            noteName = '_' + baseName;
                        }
                    } else {
                        // Use sharp spelling
                        const sharpNames = { 1: 'C', 3: 'D', 6: 'F', 8: 'G', 10: 'A' };
                        const baseName = sharpNames[noteIndex];
                        if (keySig.sharps.includes(noteIndex)) {
                            // This sharp is in the key sig - no accidental needed
                            noteName = baseName;
                        } else {
                            // Sharp not in key sig - need explicit sharp
                            noteName = '^' + baseName;
                        }
                    }
                }
            }

            // Handle octave markers in ABC notation
            // Octave 4 (middle C = MIDI 60) = uppercase C D E F G A B
            // Octave 5 = lowercase c d e f g a b
            // Octave 6+ = lowercase with apostrophes c' d'' etc.
            // Octave 3 = uppercase with commas C, D, etc.
            // Octave 2 = C,, D,, etc.

            if (octave >= 5) {
                // Lowercase for octave 5+
                noteName = noteName.toLowerCase();
                const apostrophes = octave - 5;
                noteName += "'".repeat(apostrophes);
            } else if (octave === 4) {
                // Uppercase, no modifier (middle C octave)
                // noteName stays as is
            } else {
                // Octave 3 and below - uppercase with commas
                const commas = 4 - octave;
                noteName += ",".repeat(commas);
            }

            return noteName;
        }

        // Determine best clef(s) based on note range
        function detectClef(midiNotes) {
            if (midiNotes.length === 0) return 'treble';

            const lowest = Math.min(...midiNotes);
            const highest = Math.max(...midiNotes);
            const middle = (lowest + highest) / 2;

            // Middle C = MIDI 60
            // If all notes are high (above G3/MIDI 55), use treble
            // If all notes are low (below D4/MIDI 62), use bass
            // If spanning both, we need grand staff

            if (lowest >= 55) {
                return 'treble';
            } else if (highest <= 62) {
                return 'bass';
            } else {
                return 'grand'; // Need both clefs
            }
        }

        // Generate empty staff with just clef and key signature
        function generateEmptyStaff() {
            const abcKey = getABCKeyString(selectedKeySignature);
            let abc = 'X:1\n';
            abc += 'L:1\n';
            abc += 'M:none\n';
            abc += `K:${abcKey} clef=treble\n`;
            abc += 'x |'; // Invisible rest - shows staff without notes
            return abc;
        }

        // Get the ABC key string for the selected key signature
        function getABCKeyString(keySignature) {
            if (keySignature === 'chromatic') {
                return 'C'; // C major = no key signature, we add accidentals manually
            }
            // Convert key name to ABC format
            // ABC uses: C, G, D, A, E, B, F#, Cb for major
            // and Am, Em, Bm, etc. for minor
            return keySignature;
        }

        // Generate ABC notation string for current notes
        function generateABCNotation(midiNotes) {
            if (midiNotes.length === 0) return null;

            const sortedNotes = [...midiNotes].sort((a, b) => a - b);
            const clefType = detectClef(sortedNotes);
            const abcKey = getABCKeyString(selectedKeySignature);

            if (clefType === 'grand') {
                // Split notes between bass and treble at middle C (60)
                const bassNotes = sortedNotes.filter(n => n < 60);
                const trebleNotes = sortedNotes.filter(n => n >= 60);

                // Build grand staff ABC
                let abc = 'X:1\n';
                abc += 'L:1\n'; // Whole notes
                abc += 'M:none\n'; // No time signature
                abc += '%%staves {1 2}\n';
                abc += 'V:1 clef=treble\n';
                abc += 'V:2 clef=bass\n';
                abc += `K:${abcKey}\n`;

                // Treble staff
                abc += '[V:1] ';
                if (trebleNotes.length > 0) {
                    abc += '[' + trebleNotes.map(n => midiToABC(n, selectedKeySignature)).join('') + ']';
                } else {
                    abc += 'z'; // Rest if no treble notes
                }
                abc += ' |\n';

                // Bass staff
                abc += '[V:2] ';
                if (bassNotes.length > 0) {
                    abc += '[' + bassNotes.map(n => midiToABC(n, selectedKeySignature)).join('') + ']';
                } else {
                    abc += 'z'; // Rest if no bass notes
                }
                abc += ' |';

                return abc;
            } else {
                // Single staff
                let abc = 'X:1\n';
                abc += 'L:1\n'; // Whole notes
                abc += 'M:none\n'; // No time signature
                abc += `K:${abcKey} clef=${clefType}\n`;

                // All notes as a chord
                abc += '[' + sortedNotes.map(n => midiToABC(n, selectedKeySignature)).join('') + '] |';

                return abc;
            }
        }

        // Render notation with debouncing
        function updateNotation() {
            clearTimeout(notationDebounceTimer);

            notationDebounceTimer = setTimeout(() => {
                const midiNotes = Array.from(activeNotes.keys());

                // Always render staff - show rest when no notes
                const abcString = midiNotes.length === 0
                    ? generateEmptyStaff()
                    : generateABCNotation(midiNotes);

                if (abcString && window.ABCJS) {
                    notationContainer.innerHTML = ''; // Clear placeholder
                    try {
                        ABCJS.renderAbc(notationContainer, abcString, {
                            responsive: 'resize',
                            add_classes: true,
                            staffwidth: 200,
                            paddingtop: 0,
                            paddingbottom: 0,
                            paddingleft: 0,
                            paddingright: 0
                        });
                    } catch (e) {
                        console.error('ABC notation error:', e);
                        notationContainer.innerHTML = '<span class="notation-placeholder">Notation error</span>';
                    }
                }
            }, NOTATION_DEBOUNCE_MS);
        }

        // Render initial empty staff on page load
        updateNotation();

        // ===== END LIVE STAFF NOTATION =====
    </script>
</body>
</html>
